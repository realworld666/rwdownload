<?php/* * Copyright (c) 2023. * RW::Software * Dave Conley * https://www.rwscripts.com/ */$loader = new downloader();class downloader{	function downloader()	{		global $IN;		switch ($IN["ACT"]) {			case 'dl':				$this->begin();				break;		}	}	// Main download function	function begin()	{		global $DB, $CONFIG, $IN, $rwdInfo, $std, $guser;		$dlid = intval($IN["id"]);		if (!$dlid) {			$std->error(GETLANG("er_noid"));			return;		}		if ($std->isUsingFullVersion()) {			if ($guser->getPermissions() & k_useSessionIDs) {				if (!$IN['sess']) {					$std->error(GETLANG("er_nosession"));					return;				} else if ($IN['sess'] != $IN['sid']) {					$info = "";					if (DEV_MODE)						$info = "{$IN['sess']} != {$IN['sid']}";					$std->error(GETLANG("er_invalidsess") . $info);					return;				}			}			$guser->updateMemberExtra("`{$guser->db_id}`='{$guser->userid}'", "`mid`='{$guser->userid}'");			$std->updateLimits($guser->userdetails);		}		$result = $DB->query("SELECT l.*, sym.sym_catid FROM `dl_links` l                                LEFT JOIN `dl_symlinks` sym ON (sym.sym_did=l.did)                                WHERE l.did='{$dlid}'");		if (!$myrow = $DB->fetch_row($result)) {			$std->error(GETLANG("er_nofile"));			return;		}		if ($std->canDownloadFiles($myrow)) {			$valid = false;			$leech_protection = ($CONFIG["leech_protect"] and $std->isUsingFullVersion());			if ($leech_protection) {				$reason = $IN["referer"] . "<br>" . GETLANG("invalidreferer");				if ($IN["referer"]) {					$r = parse_url($IN["referer"]);					$referer = $r['scheme'] . "://" . $r['host'] . "/";				} else					$referer = "";				if ($CONFIG["referers"]) {					$vals = explode("\n", $CONFIG["referers"]);					foreach ($vals as $v) {						if ($referer == "") {							if ($CONFIG['leech_allownorefer'])								$valid = true;							else {								$valid = false;								$reason = GETLANG("noreferer");							}						}						// Check if referer key is in refering url						if (stristr($referer, $v) and !$valid) {							// if so set valid referer to true and break out							$valid = true;							break;						}					}				}				if (!$valid) {					$std->addLeechLog($IN['symid'], $myrow['name']);					$std->error($reason);				}			}			if ($valid || !$leech_protection) {				if (!($guser->getPermissions() & k_noRestrict) and $std->isUsingFullVersion()) {					if ($guser->userdetails['dlLimitFiles'] <= 0) {						$std->error(GETLANG("er_filelimitsused"));						return;					}					if ($guser->userdetails['dlLimitSize'] < $myrow['realsize']) {						$std->error(GETLANG("er_bwlimitsused"));						return;					}				}				// Get real url to file				if ($std->isExternalFile($myrow['download'])) {					$dl_url = $myrow["download"];					$dl_path = "";				} else {					if ($myrow["maskName"]) {						$dl_url = $CONFIG['filesurl'] . "/" . $myrow["maskName"];						$dl_path = $CONFIG['filesfolder'] . "/" . $myrow["maskName"];					} else {						$dl_url = $CONFIG['filesurl'] . "/" . $myrow["download"];						$dl_path = $CONFIG['filesfolder'] . "/" . $myrow["download"];					}					if ($CONFIG['hta_user']) {						$urlBits[] = parse_url($dl_url);						$dl_url = $urlBits[0]['scheme'] . "://" . $CONFIG['hta_user'] . ":" . $CONFIG['hta_pass'] . "@" . $urlBits[0]['host'] . $urlBits[0]['path'] . $urlBits[0]['query'] . $urlBits[0]['fragment'];					}				}				if (file_exists($dl_path) || $dl_path == "") {					// If path is blank no need to show this because its an external file					if ($dl_path) {						$filename = $myrow["download"];					} else {						preg_match("/([^\/]+\.\w{1,})$/", $myrow["download"], $arMatches);						$filename = $arMatches[1];					}					$filetype = $myrow["fileType"];					if ($filetype == "")						$filetype = "application/octet-stream";					if ($dl_path) {						// If its a local file file then check we can open it						if ($CONFIG['hta_user'])							$fh = @fopen($dl_url, 'rb');  // It seems we're going to have to use fopen on a url if we're protecting with .htaccess						else							$fh = @fopen($dl_path, 'rb'); // path is more reliable						if (!$fh) {							if ($CONFIG['hta_user'])								$std->error(GETLANG("er_fopenfail") . "<br>" . $dl_url);							else								$std->error(GETLANG("er_fopenfail") . "<br>" . $dl_path);							return;						}					} else {						if ($dl_path == "" and $CONFIG['externalmethod']) {							$fh = @fopen($dl_url, 'rb');							if (!$fh) {								$std->error(GETLANG("er_fopenfail") . "<br>" . $dl_url);								return;							}						}					}					// Update download count					$DB->query("UPDATE dl_links SET downloads=downloads+1 WHERE did=$dlid");					if (!($guser->getPermissions() & k_noRestrict) and $std->isUsingFullVersion()) {						$update = array("dlLimitSize" => $guser->userdetails['dlLimitSize'] - $myrow["realsize"],							"dlLimitFiles" => "dlLimitFiles-1");					}					$update["downloaded"] = "downloaded+1";					if ($std->isUsingFullVersion()) {						$DB->update($update, "dl_memberextra", "mid={$guser->userid}");						$std->addDownloadLog($IN['symid'], $myrow['name']);					}// ===========================================================================================					// Done with database now. NO SQL queries after this point!					$guser->userdb->close_db();					$DB->close_db();// ===========================================================================================					if ($dl_path || $CONFIG['externalmethod']) { // ***** If there is a dl path, then it's on our server...						// Pointless doing this if we dont know the filesize!						if ($myrow["realsize"] and $CONFIG['partial_transfers'] and isset($_SERVER['HTTP_RANGE'])) {							ob_end_clean();							// Support for partial transfers enabled and browser requested a partial transfer							header("HTTP/1.1 206 Partial content\n");							$start = preg_replace(array("/(\040*|)bytes(\040*|)=(\040*|)/", "/(\040*|)\-.*$/"), array("", ""), $_SERVER['HTTP_RANGE']);							if ($myrow["realsize"] < $start) {								header("HTTP/1.1 411 Length Required\n");								echo "Trying to download past the end of the file. You have probably requested the wrong file. Please try again.";							}							$transfer_size = $myrow["realsize"] - $start;							header("Accept-Ranges: bytes");							header("Content-Range: bytes " . $transfer_size . "-" . ($myrow["realsize"] - 1) . "/" . $myrow["realsize"]);							header("Content-Length:" . $transfer_size . "\n");							fseek($fh, $startat_byte);						} else {							header("HTTP/1.1 200 OK\n");							if ($myrow["realsize"])								header("Content-Length: " . (string)($myrow["realsize"]));						}						ob_end_clean();						// Print the http header						header("Cache-control: private\n"); // fix for IE to correctly download files						header("Pragma: no-cache\n");       // fix for http/1.0						header("Content-Type: " . $filetype);						header("Content-Disposition: attachment; filename=" . $filename);						header("Content-Transfer-Encoding: binary");						if ($CONFIG['nopassthrough']) {							if ($CONFIG['speedlimit'] != 0) {								$chunk = $CONFIG['speedlimit'] * 1024;								// Stream our file in chunks								while (!feof($fh)) {									echo fread($fh, $chunk);									flush();									sleep(1);								}							} else {								// File streaming for the impatient								while (!feof($fh)) {									echo fread($fh, 4096);								}							}						} else {							// The old faithful							fpassthru($fh);						}						fclose($fh);					} else {						ob_end_clean();						// External link...						header("Location: {$myrow['download']}"); // Do a redirect once we've logged everything dude!					}					exit();				} else					$std->error(GETLANG("er_missinglink") . "<br>" . $dl_path);			}		} else			$std->error(GETLANG("er_noaccess"));	}}?>